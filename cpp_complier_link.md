##C++编译链接模型笔记

####第一节
- C++语言的三大约束是：与C兼容，零开销，值语义。
- 与C兼容：不仅是语法兼容，更重要的是兼容C语言的编译模型与运行模型，也就是能直接使用
  C语言的头文件。
- 编译的步骤：preprocessor/complier/assembler/linker
- include的缺点： 让编译效率降低。留下安全隐患，头文件有传递性，可能引入不必要的依赖。
- gcc -E *.cc 预处理 

####第二节
- 单遍编译，C++继承了C的单遍编译，但是影响了名字查找和函数重载决议。
- 所谓单遍编译，指的是从头到尾扫描一遍源码，一边解析源码，一边生成目标代码，也就是编译时，只能看到
目前已经解析过的源码，看不到后面的源码，也是C语言中需要函数声明的原因。结构体必须先定义。
- AA BB(CC);这句话既可以声明函数，也可以定义变量。
- C++ 只能通过解析源码来了解名字的含义。意味着要准确理解一行代码的意义，需要通读之前的所有代码。
- 函数重载决议，当C++编译器读到一个函数调用时，它必须从已经看到的同名函数中选出最佳的函数，哪怕后面
出现了更合适的匹配。
- 前向声明
- 在.h文件里声明函数，在.CC文件里实现函数，但是有缺陷，即一样的东西区分声明和定义，代码放在
不同的文件中，这就有了出错的可能，比如在一个源文件里声明 extern char *name,但是到了另一个源文件里成了
char name[] = "chen shuo";.
- 对于函数而言，这种不一致表现在参数列表和返回类型上。
- 对于 class Foo 以下几种情况不需要看见其完整的定义：1,定义或声明Foo*和Foo&，包括用于函数参数，返回类型
，局部变量，类成员变量等。2,声明一个Foo为参数或返回类型的函数，如 Foo bar(),或者 void bar(Foo f),但是如
果代码里调用这个函数就需要知道Foo的定义，因为编译器要知道Foo的拷贝构造函数和析构函数。
- 不能重载operator&，因为一旦重载，这个class就不能用前向声明了。
####第三节 链接
- 为了实现函数重载，c++编译器采用名字改编的办法，为每个重载函数生成独一无二的名字，这样链接的时候就能找
到正确的函数。
- 返回类型不参与函数重载。
- 重复代码消除：如果编译器如法inline展开的话，每个编译单元都会生成inline函数的目标代码，然后linker
会从多分实现中任选一份保留，其余的则丢弃（vague linkage）。
- 如何判断一个C++可执行文件是debug build 还是 release build？通常的做法是判断class template 的短函数
成员有没有被inline展开。
- g++ -Wall *.cc 没有优化的bulid，不会inline展开。debug build.
- g++ -Wall -o2 *.cc inline展开。release build.
- 编译器自动生成的析构函数也是inline的
- 模板的定义一般要放到头文件中，否则会有编译错误，但是所谓的编译错误只是链接错误，有办法将模板的实现
放到*.cc文件里，头文件里只放声明，前提是你知道模板会有那些具体化类型，并事先显式具体化出来。如：
 template<typename T>
 T bar(const T& x)
 {
	/....
 }
 template char bar(const char&);//*.cc 具体化
- 虚函数
- 虚函数的调用是通过虚函数表（vtable）进行的，每个多态的class都应该有一份vtable。定义或继承了虚函数的
对象中会有一个隐含的成员：指向vtable的指针，即vptr。在析构或者构造对象的时候，编译器会修改bptr成员。
 

